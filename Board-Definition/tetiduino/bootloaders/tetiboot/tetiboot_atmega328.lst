
tetiboot_atmega328.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000222  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001ce  00007e00  00007e00  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000011  00000000  00000000  00000222  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000028  00000000  00000000  00000233  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000005f4  00000000  00000000  0000025b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000223  00000000  00000000  0000084f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000003c2  00000000  00000000  00000a72  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  0000008c  00000000  00000000  00000e34  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000001eb  00000000  00000000  00000ec0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000032b  00000000  00000000  000010ab  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000090  00000000  00000000  000013d6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007e00 <main>:
int main() {
    uint8_t ch;
    register uint16_t address;
    register uint8_t bytelength;
    
    asm volatile ("clr __zero_reg__");
    7e00:	11 24       	eor	r1, r1
    ch = MCUSR;
    7e02:	84 b7       	in	r24, 0x34	; 52
    MCUSR = 0;
    7e04:	14 be       	out	0x34, r1	; 52
    WDTCSR = _BV(WDCE) | _BV(WDE);
    WDTCSR = timeout;
}

static inline void resetWatchdog() {
    __asm__ __volatile__ ("wdr\n");
    7e06:	a8 95       	wdr
#define WD_4S     (_BV(WDP3) | _BV(WDE))
#define WD_8S     (_BV(WDP3) | _BV(WDP0) | _BV(WDE))

static inline void setWatchdog(uint8_t timeout) {
    resetWatchdog();
    WDTCSR = _BV(WDCE) | _BV(WDE);
    7e08:	18 e1       	ldi	r17, 0x18	; 24
    7e0a:	10 93 60 00 	sts	0x0060, r17	; 0x800060 <__DATA_REGION_ORIGIN__>
    WDTCSR = timeout;
    7e0e:	9e e0       	ldi	r25, 0x0E	; 14
    7e10:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>

    setWatchdog(WD_1S);
    // Set up Timer 1 for timeout counter
    TCCR1B = _BV(CS12) | _BV(CS10); // div 1024
    7e14:	95 e0       	ldi	r25, 0x05	; 5
    7e16:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>

    if (ch & _BV(EXTRF)) {
    7e1a:	81 ff       	sbrs	r24, 1
    7e1c:	8d c0       	rjmp	.+282    	; 0x7f38 <main+0x138>
        // external reset, start bootloader
        flashLED(2, PINB2);
    7e1e:	62 e0       	ldi	r22, 0x02	; 2
    7e20:	82 e0       	ldi	r24, 0x02	; 2
    7e22:	90 d0       	rcall	.+288    	; 0x7f44 <flashLED>

        // set up UART comm at 115200 baud
        UCSR0A = _BV(U2X0); //Double speed mode USART0
    7e24:	82 e0       	ldi	r24, 0x02	; 2
    7e26:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
        UCSR0B = _BV(RXEN0) | _BV(TXEN0);
    7e2a:	10 93 c1 00 	sts	0x00C1, r17	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
        UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
    7e2e:	86 e0       	ldi	r24, 0x06	; 6
    7e30:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
        UBRR0L = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1);
    7e34:	85 e1       	ldi	r24, 0x15	; 21
    7e36:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    // - Set up the address in the Z pointer
    // - Set up the data in R1:R0
    // - Write 0x01 to SPMCSR
    // - Do SPM
    static const uint8_t fill = 0x01;
    __asm__ __volatile__ (
    7e3a:	01 e0       	ldi	r16, 0x01	; 1
    // To erase a page:
    // - Set up the address in the Z pointer
    // - Write 0x03 to SPMCSR
    // - Do SPM
    static const uint8_t erase = 0x03;
    __asm__ __volatile__ (
    7e3c:	23 e0       	ldi	r18, 0x03	; 3
    7e3e:	d2 2e       	mov	r13, r18
    // To write a page:
    // - Set up the address in the Z pointer
    // - Write 0x05 to SPMCSR
    // - Do SPM
    static const uint8_t write = 0x05;
    __asm__ __volatile__ (
    7e40:	35 e0       	ldi	r19, 0x05	; 5
    7e42:	c3 2e       	mov	r12, r19
    // To re-enable RWW section:
    // - Ensure previous SPM instruction is done
    // - Write 0x11 to SPMCSR
    // - Do SPM
    static const uint8_t rww_reenable = 0x11;
    __asm__ __volatile__ (
    7e44:	41 e1       	ldi	r20, 0x11	; 17

        for (;;) {
            /* get character from UART */
            ch = getch();
    7e46:	b4 2e       	mov	r11, r20
    7e48:	a7 d0       	rcall	.+334    	; 0x7f98 <getch>

            if(ch == STK_GET_PARAMETER) {
    7e4a:	81 34       	cpi	r24, 0x41	; 65
                getch();
    7e4c:	29 f4       	brne	.+10     	; 0x7e58 <main+0x58>
                waitForEOP();
    7e4e:	a4 d0       	rcall	.+328    	; 0x7f98 <getch>
    7e50:	af d0       	rcall	.+350    	; 0x7fb0 <waitForEOP>
                putch(0x03);
    7e52:	83 e0       	ldi	r24, 0x03	; 3
    7e54:	9a d0       	rcall	.+308    	; 0x7f8a <putch>
    7e56:	6d c0       	rjmp	.+218    	; 0x7f32 <main+0x132>
            }
            else if(ch == STK_READ_SIGN) {
    7e58:	85 37       	cpi	r24, 0x75	; 117
                waitForEOP();
    7e5a:	41 f4       	brne	.+16     	; 0x7e6c <main+0x6c>
                putch(SIGNATURE_0);
    7e5c:	a9 d0       	rcall	.+338    	; 0x7fb0 <waitForEOP>
    7e5e:	8e e1       	ldi	r24, 0x1E	; 30
    7e60:	94 d0       	rcall	.+296    	; 0x7f8a <putch>
                putch(SIGNATURE_1);
    7e62:	85 e9       	ldi	r24, 0x95	; 149
    7e64:	92 d0       	rcall	.+292    	; 0x7f8a <putch>
                putch(SIGNATURE_2);
    7e66:	8f e0       	ldi	r24, 0x0F	; 15
    7e68:	90 d0       	rcall	.+288    	; 0x7f8a <putch>
    7e6a:	63 c0       	rjmp	.+198    	; 0x7f32 <main+0x132>
    7e6c:	82 34       	cpi	r24, 0x42	; 66
            }
            else if(ch == STK_SET_DEVICE) {
    7e6e:	21 f4       	brne	.+8      	; 0x7e78 <main+0x78>
                ignoreCommand(20);
    7e70:	84 e1       	ldi	r24, 0x14	; 20
    7e72:	a5 d0       	rcall	.+330    	; 0x7fbe <ignoreCommand>
    7e74:	9d d0       	rcall	.+314    	; 0x7fb0 <waitForEOP>
                waitForEOP();
    7e76:	5d c0       	rjmp	.+186    	; 0x7f32 <main+0x132>
    7e78:	85 34       	cpi	r24, 0x45	; 69
            }
            else if(ch == STK_SET_DEVICE_EXT) {
    7e7a:	21 f4       	brne	.+8      	; 0x7e84 <main+0x84>
    7e7c:	85 e0       	ldi	r24, 0x05	; 5
                ignoreCommand(5);
    7e7e:	9f d0       	rcall	.+318    	; 0x7fbe <ignoreCommand>
    7e80:	97 d0       	rcall	.+302    	; 0x7fb0 <waitForEOP>
                waitForEOP();
    7e82:	57 c0       	rjmp	.+174    	; 0x7f32 <main+0x132>
    7e84:	86 35       	cpi	r24, 0x56	; 86
            }
            else if(ch == STK_UNIVERSAL) {
    7e86:	21 f4       	brne	.+8      	; 0x7e90 <main+0x90>
                ignoreCommand(4);
    7e88:	84 e0       	ldi	r24, 0x04	; 4
    7e8a:	99 d0       	rcall	.+306    	; 0x7fbe <ignoreCommand>
    7e8c:	91 d0       	rcall	.+290    	; 0x7fb0 <waitForEOP>
                waitForEOP();
    7e8e:	51 c0       	rjmp	.+162    	; 0x7f32 <main+0x132>
    7e90:	85 35       	cpi	r24, 0x55	; 85
            }
            else if(ch == STK_LOAD_ADDRESS) {
    7e92:	41 f4       	brne	.+16     	; 0x7ea4 <main+0xa4>
    7e94:	81 d0       	rcall	.+258    	; 0x7f98 <getch>
                uint8_t addr_low = getch();
    7e96:	c8 2f       	mov	r28, r24
    7e98:	7f d0       	rcall	.+254    	; 0x7f98 <getch>
                uint8_t addr_high = getch();
    7e9a:	d8 2f       	mov	r29, r24
    7e9c:	cc 0f       	add	r28, r28
                address = (addr_high << 8) | (addr_low);
                address *= 2; // to byte address
    7e9e:	dd 1f       	adc	r29, r29
    7ea0:	87 d0       	rcall	.+270    	; 0x7fb0 <waitForEOP>
                waitForEOP();
    7ea2:	47 c0       	rjmp	.+142    	; 0x7f32 <main+0x132>
    7ea4:	84 36       	cpi	r24, 0x64	; 100
    7ea6:	09 f0       	breq	.+2      	; 0x7eaa <main+0xaa>
            }
            else if(ch == STK_PROG_PAGE) {
    7ea8:	31 c0       	rjmp	.+98     	; 0x7f0c <main+0x10c>
    7eaa:	76 d0       	rcall	.+236    	; 0x7f98 <getch>
                uint8_t* sram;
                uint8_t bytelength, wordlength;
                uint16_t word;
                uint16_t addr = address;

                getch();
    7eac:	75 d0       	rcall	.+234    	; 0x7f98 <getch>
    7eae:	a8 2e       	mov	r10, r24
                bytelength = getch();
    7eb0:	18 2f       	mov	r17, r24
    7eb2:	16 95       	lsr	r17
    7eb4:	71 d0       	rcall	.+226    	; 0x7f98 <getch>
                wordlength = bytelength / 2;
    7eb6:	e1 2c       	mov	r14, r1
    7eb8:	ff 24       	eor	r15, r15
                getch();
    7eba:	f3 94       	inc	r15
    7ebc:	6d d0       	rcall	.+218    	; 0x7f98 <getch>

                sram = buff;
    7ebe:	f7 01       	movw	r30, r14
    7ec0:	81 93       	st	Z+, r24
    7ec2:	7f 01       	movw	r14, r30
                do {
                    *sram = getch();
    7ec4:	ae 12       	cpse	r10, r30
    7ec6:	fa cf       	rjmp	.-12     	; 0x7ebc <main+0xbc>
    7ec8:	73 d0       	rcall	.+230    	; 0x7fb0 <waitForEOP>
    7eca:	fe 01       	movw	r30, r28
    7ecc:	a0 e0       	ldi	r26, 0x00	; 0
                    sram++;
                } while (--bytelength);
    7ece:	b1 e0       	ldi	r27, 0x01	; 1
    7ed0:	9c 91       	ld	r25, X

                waitForEOP();
    7ed2:	11 96       	adiw	r26, 0x01	; 1
    7ed4:	8c 91       	ld	r24, X
            }
            else if(ch == STK_PROG_PAGE) {
                uint8_t* sram;
                uint8_t bytelength, wordlength;
                uint16_t word;
                uint16_t addr = address;
    7ed6:	11 97       	sbiw	r26, 0x01	; 1
                    sram++;
                } while (--bytelength);

                waitForEOP();

                sram = buff;
    7ed8:	89 27       	eor	r24, r25
    7eda:	98 27       	eor	r25, r24
                do {
                    word = (*sram);
    7edc:	89 27       	eor	r24, r25
                    sram++;
                    word |= (*sram) << 8;
    7ede:	12 96       	adiw	r26, 0x02	; 2
    7ee0:	0c 01       	movw	r0, r24
    7ee2:	07 bf       	out	0x37, r16	; 55
    7ee4:	e8 95       	spm
    7ee6:	11 24       	eor	r1, r1
    7ee8:	32 96       	adiw	r30, 0x02	; 2
    7eea:	11 50       	subi	r17, 0x01	; 1
    // - Set up the address in the Z pointer
    // - Set up the data in R1:R0
    // - Write 0x01 to SPMCSR
    // - Do SPM
    static const uint8_t fill = 0x01;
    __asm__ __volatile__ (
    7eec:	89 f7       	brne	.-30     	; 0x7ed0 <main+0xd0>
    7eee:	fe 01       	movw	r30, r28
                    sram++;
                    spm_fill_buffer(addr, word);
                    addr += 2;
                } while (--wordlength);
    7ef0:	d7 be       	out	0x37, r13	; 55
    // To erase a page:
    // - Set up the address in the Z pointer
    // - Write 0x03 to SPMCSR
    // - Do SPM
    static const uint8_t erase = 0x03;
    __asm__ __volatile__ (
    7ef2:	e8 95       	spm
    7ef4:	07 b6       	in	r0, 0x37	; 55
                spm_erase(address);
                while(SPMCSR & _BV(SPMEN));
    7ef6:	00 fc       	sbrc	r0, 0
    7ef8:	fd cf       	rjmp	.-6      	; 0x7ef4 <main+0xf4>
    7efa:	fe 01       	movw	r30, r28
    // To write a page:
    // - Set up the address in the Z pointer
    // - Write 0x05 to SPMCSR
    // - Do SPM
    static const uint8_t write = 0x05;
    __asm__ __volatile__ (
    7efc:	c7 be       	out	0x37, r12	; 55
    7efe:	e8 95       	spm
                spm_write(address);
                while(SPMCSR & _BV(SPMEN));
    7f00:	07 b6       	in	r0, 0x37	; 55
    7f02:	00 fc       	sbrc	r0, 0
    // To re-enable RWW section:
    // - Ensure previous SPM instruction is done
    // - Write 0x11 to SPMCSR
    // - Do SPM
    static const uint8_t rww_reenable = 0x11;
    __asm__ __volatile__ (
    7f04:	fd cf       	rjmp	.-6      	; 0x7f00 <main+0x100>
    7f06:	b7 be       	out	0x37, r11	; 55
                // for(uint8_t i = 0; i < 128; i++) {
                //     buff[i] = getch();
                //     //*buff++ = getch();
                // }
            }
            else if(ch == STK_READ_PAGE) {
    7f08:	e8 95       	spm
                getch();
    7f0a:	13 c0       	rjmp	.+38     	; 0x7f32 <main+0x132>
                bytelength = getch();
    7f0c:	84 37       	cpi	r24, 0x74	; 116
    7f0e:	61 f4       	brne	.+24     	; 0x7f28 <main+0x128>
    7f10:	43 d0       	rcall	.+134    	; 0x7f98 <getch>
                getch();
    7f12:	42 d0       	rcall	.+132    	; 0x7f98 <getch>
    7f14:	18 2f       	mov	r17, r24
                waitForEOP();
    7f16:	40 d0       	rcall	.+128    	; 0x7f98 <getch>
    7f18:	4b d0       	rcall	.+150    	; 0x7fb0 <waitForEOP>
    // - Load address to the Z pointer
    // - Specify destination address (default: r0)
    // - Do LPM
    char ch;

    __asm__ __volatile__ ("" : : "z" (address));
    7f1a:	fe 01       	movw	r30, r28
    7f1c:	02 c0       	rjmp	.+4      	; 0x7f22 <main+0x122>
    while (length--) {
        __asm__ __volatile__ (
    7f1e:	85 91       	lpm	r24, Z+
            "lpm %[ch], Z+\n\t"
            : [ch] "=r" (ch)
        );
        putch(ch);
    7f20:	34 d0       	rcall	.+104    	; 0x7f8a <putch>
    7f22:	11 50       	subi	r17, 0x01	; 1
    // - Specify destination address (default: r0)
    // - Do LPM
    char ch;

    __asm__ __volatile__ ("" : : "z" (address));
    while (length--) {
    7f24:	e0 f7       	brcc	.-8      	; 0x7f1e <main+0x11e>
    7f26:	05 c0       	rjmp	.+10     	; 0x7f32 <main+0x132>
    7f28:	81 35       	cpi	r24, 0x51	; 81
                // for(uint8_t i = 0; i < 128; i++) {
                //     putch(buff[i]);
                //     //putch(*buff++);
                // } 
            }
            else if (ch == STK_LEAVE_PROGMODE) {
    7f2a:	11 f4       	brne	.+4      	; 0x7f30 <main+0x130>
    7f2c:	41 d0       	rcall	.+130    	; 0x7fb0 <waitForEOP>
                waitForEOP();
    7f2e:	01 c0       	rjmp	.+2      	; 0x7f32 <main+0x132>
    7f30:	3f d0       	rcall	.+126    	; 0x7fb0 <waitForEOP>
    7f32:	80 e1       	ldi	r24, 0x10	; 16
            }
            else {
                waitForEOP();
    7f34:	2a d0       	rcall	.+84     	; 0x7f8a <putch>
    7f36:	88 cf       	rjmp	.-240    	; 0x7e48 <main+0x48>
            }

            putch(STK_OK);
    7f38:	63 e0       	ldi	r22, 0x03	; 3
    7f3a:	82 e0       	ldi	r24, 0x02	; 2
    7f3c:	03 d0       	rcall	.+6      	; 0x7f44 <flashLED>
        UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
        UBRR0L = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1);

        for (;;) {
            /* get character from UART */
            ch = getch();
    7f3e:	1c d0       	rcall	.+56     	; 0x7f78 <jumpToApp>
        //     flashLED(6, PINB2);
        // }
    }
    else {
        // other reset source, jump directly to app
        flashLED(2, PINB3);
    7f40:	90 e0       	ldi	r25, 0x00	; 0
    7f42:	80 e0       	ldi	r24, 0x00	; 0

00007f44 <flashLED>:
    7f44:	94 b1       	in	r25, 0x04	; 4
    7f46:	21 e0       	ldi	r18, 0x01	; 1
        jumpToApp();
    7f48:	30 e0       	ldi	r19, 0x00	; 0
    7f4a:	01 c0       	rjmp	.+2      	; 0x7f4e <flashLED+0xa>
    }
}
    7f4c:	22 0f       	add	r18, r18
    7f4e:	6a 95       	dec	r22

void flashLED(uint8_t count, uint8_t pin) {
    /* Set LED pin as output */
    DDRB |= _BV(pin);
    7f50:	ea f7       	brpl	.-6      	; 0x7f4c <flashLED+0x8>
    7f52:	32 2f       	mov	r19, r18
    7f54:	29 2b       	or	r18, r25
    7f56:	24 b9       	out	0x04, r18	; 4

    do {
        TCNT1 = -(F_CPU/(1024*16));
    7f58:	4c e3       	ldi	r20, 0x3C	; 60
    7f5a:	5b ef       	ldi	r21, 0xFB	; 251
        TIFR1 = _BV(TOV1);
    7f5c:	21 e0       	ldi	r18, 0x01	; 1
void flashLED(uint8_t count, uint8_t pin) {
    /* Set LED pin as output */
    DDRB |= _BV(pin);

    do {
        TCNT1 = -(F_CPU/(1024*16));
    7f5e:	50 93 85 00 	sts	0x0085, r21	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    7f62:	40 93 84 00 	sts	0x0084, r20	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
        TIFR1 = _BV(TOV1);
    7f66:	26 bb       	out	0x16, r18	; 22
        // wait until timer overflow
        while(!(TIFR1 & _BV(TOV1)));
    7f68:	b0 9b       	sbis	0x16, 0	; 22
    7f6a:	fe cf       	rjmp	.-4      	; 0x7f68 <flashLED+0x24>
        // toggle pin
        PINB |= _BV(pin);
    7f6c:	93 b1       	in	r25, 0x03	; 3
    7f6e:	93 2b       	or	r25, r19
    7f70:	93 b9       	out	0x03, r25	; 3
    } while (--count);
    7f72:	81 50       	subi	r24, 0x01	; 1
    7f74:	a1 f7       	brne	.-24     	; 0x7f5e <flashLED+0x1a>
}
    7f76:	08 95       	ret

00007f78 <jumpToApp>:
}

static inline void resetWatchdog() {
    __asm__ __volatile__ ("wdr\n");
    7f78:	a8 95       	wdr
#define WD_4S     (_BV(WDP3) | _BV(WDE))
#define WD_8S     (_BV(WDP3) | _BV(WDP0) | _BV(WDE))

static inline void setWatchdog(uint8_t timeout) {
    resetWatchdog();
    WDTCSR = _BV(WDCE) | _BV(WDE);
    7f7a:	e0 e6       	ldi	r30, 0x60	; 96
    7f7c:	f0 e0       	ldi	r31, 0x00	; 0
    7f7e:	88 e1       	ldi	r24, 0x18	; 24
    7f80:	80 83       	st	Z, r24
    WDTCSR = timeout;
    7f82:	10 82       	st	Z, r1
void jumpToApp() {
    // Jump to app start address (0x0000)
    // this is done by setting the Z register (R31:R30) to 0
    // and do indirect jump (IJMP)
    setWatchdog(WD_OFF);
    __asm__ __volatile__ (
    7f84:	ee 27       	eor	r30, r30
    7f86:	ff 27       	eor	r31, r31
    7f88:	09 94       	ijmp

00007f8a <putch>:
        "ijmp\n"
    );
}

void putch(char ch) {
    while (!(UCSR0A & _BV(UDRE0)));
    7f8a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    7f8e:	95 ff       	sbrs	r25, 5
    7f90:	fc cf       	rjmp	.-8      	; 0x7f8a <putch>
    UDR0 = ch; 
    7f92:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
}
    7f96:	08 95       	ret

00007f98 <getch>:

char getch() {
    char ch;
    while (!(UCSR0A & _BV(RXC0)));
    7f98:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    7f9c:	87 ff       	sbrs	r24, 7
    7f9e:	fc cf       	rjmp	.-8      	; 0x7f98 <getch>
    if (!(UCSR0A & _BV(FE0))) {
    7fa0:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    7fa4:	84 fd       	sbrc	r24, 4
    7fa6:	01 c0       	rjmp	.+2      	; 0x7faa <getch+0x12>
}

static inline void resetWatchdog() {
    __asm__ __volatile__ ("wdr\n");
    7fa8:	a8 95       	wdr
        // Frame not error
        resetWatchdog();
    }
    ch = UDR0;
    7faa:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    return ch;
}
    7fae:	08 95       	ret

00007fb0 <waitForEOP>:

void waitForEOP() {
    if(getch() == CRC_EOP) {
    7fb0:	f3 df       	rcall	.-26     	; 0x7f98 <getch>
    7fb2:	80 32       	cpi	r24, 0x20	; 32
    7fb4:	11 f4       	brne	.+4      	; 0x7fba <waitForEOP+0xa>
        putch(STK_INSYNC);
    }
    else {
        putch(STK_NOSYNC);
    7fb6:	84 e1       	ldi	r24, 0x14	; 20
    7fb8:	e8 cf       	rjmp	.-48     	; 0x7f8a <putch>
    7fba:	85 e1       	ldi	r24, 0x15	; 21
    7fbc:	fd cf       	rjmp	.-6      	; 0x7fb8 <waitForEOP+0x8>

00007fbe <ignoreCommand>:
    }
}

void ignoreCommand(uint8_t length) {
    7fbe:	cf 93       	push	r28
    7fc0:	c8 2f       	mov	r28, r24
    while (length--) {
    7fc2:	c1 50       	subi	r28, 0x01	; 1
    7fc4:	10 f4       	brcc	.+4      	; 0x7fca <ignoreCommand+0xc>
        getch();
    };
}
    7fc6:	cf 91       	pop	r28
    }
}

void ignoreCommand(uint8_t length) {
    while (length--) {
        getch();
    7fc8:	08 95       	ret
    7fca:	e6 df       	rcall	.-52     	; 0x7f98 <getch>
    7fcc:	fa cf       	rjmp	.-12     	; 0x7fc2 <ignoreCommand+0x4>
