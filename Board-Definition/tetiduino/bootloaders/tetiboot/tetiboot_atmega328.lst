
tetiboot_atmega328.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000000c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000074  00007e00  00007e00  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000011  00000000  00000000  000000c8  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000028  00000000  00000000  000000d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000017a  00000000  00000000  00000101  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000011d  00000000  00000000  0000027b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000157  00000000  00000000  00000398  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000044  00000000  00000000  000004f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000013b  00000000  00000000  00000534  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000064  00000000  00000000  0000066f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000018  00000000  00000000  000006d3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007e00 <main>:
void flashLED(uint8_t, uint8_t);

int main() {
    uint8_t ch;
    
    asm volatile ("clr __zero_reg__");
    7e00:	11 24       	eor	r1, r1

    ch = MCUSR;
    7e02:	84 b7       	in	r24, 0x34	; 52
    MCUSR = 0;
    7e04:	14 be       	out	0x34, r1	; 52
#define WD_2S     (_BV(WDP2) | _BV(WDP1) | _BV(WDP0) | _BV(WDE))
#define WD_4S     (_BV(WDP3) | _BV(WDE))
#define WD_8S     (_BV(WDP3) | _BV(WDP0) | _BV(WDE))

static inline void setWatchdog(uint8_t timeout) {
    WDTCSR = _BV(WDCE) | _BV(WDE);
    7e06:	98 e1       	ldi	r25, 0x18	; 24
    7e08:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    WDTCSR = timeout;
    7e0c:	9e e0       	ldi	r25, 0x0E	; 14
    7e0e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>

    setWatchdog(WD_1S);

    // Set up Timer 1 for timeout counter
    TCCR1B = _BV(CS12) | _BV(CS10); // div 1024
    7e12:	95 e0       	ldi	r25, 0x05	; 5
    7e14:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>

    if (ch & _BV(EXTRF)) {
    7e18:	81 ff       	sbrs	r24, 1
    7e1a:	04 c0       	rjmp	.+8      	; 0x7e24 <main+0x24>
        // external reset
        //setWatchdog(WD_16MS);
        while(1) {
            flashLED(6, PINB2);
    7e1c:	62 e0       	ldi	r22, 0x02	; 2
    7e1e:	86 e0       	ldi	r24, 0x06	; 6
    7e20:	07 d0       	rcall	.+14     	; 0x7e30 <flashLED>
    7e22:	fc cf       	rjmp	.-8      	; 0x7e1c <main+0x1c>
        }
    }
    else {
        // other reset source
        flashLED(2, PINB1);
    7e24:	61 e0       	ldi	r22, 0x01	; 1
    7e26:	82 e0       	ldi	r24, 0x02	; 2
        jumpToApp();
    7e28:	03 d0       	rcall	.+6      	; 0x7e30 <flashLED>
    7e2a:	1c d0       	rcall	.+56     	; 0x7e64 <jumpToApp>
    }
}
    7e2c:	90 e0       	ldi	r25, 0x00	; 0
    7e2e:	80 e0       	ldi	r24, 0x00	; 0

00007e30 <flashLED>:

void flashLED(uint8_t count, uint8_t pin) {
  /* Set LED pin as output */
  DDRB |= _BV(pin);
    7e30:	94 b1       	in	r25, 0x04	; 4
    7e32:	21 e0       	ldi	r18, 0x01	; 1
    7e34:	30 e0       	ldi	r19, 0x00	; 0
    7e36:	01 c0       	rjmp	.+2      	; 0x7e3a <flashLED+0xa>
    7e38:	22 0f       	add	r18, r18
    7e3a:	6a 95       	dec	r22
    7e3c:	ea f7       	brpl	.-6      	; 0x7e38 <flashLED+0x8>
    7e3e:	32 2f       	mov	r19, r18
    7e40:	29 2b       	or	r18, r25
    7e42:	24 b9       	out	0x04, r18	; 4

  do {
    TCNT1 = -(F_CPU/(1024*16));
    7e44:	40 e3       	ldi	r20, 0x30	; 48
    7e46:	5c ef       	ldi	r21, 0xFC	; 252
    TIFR1 = _BV(TOV1);
    7e48:	21 e0       	ldi	r18, 0x01	; 1
void flashLED(uint8_t count, uint8_t pin) {
  /* Set LED pin as output */
  DDRB |= _BV(pin);

  do {
    TCNT1 = -(F_CPU/(1024*16));
    7e4a:	50 93 85 00 	sts	0x0085, r21	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    7e4e:	40 93 84 00 	sts	0x0084, r20	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    TIFR1 = _BV(TOV1);
    7e52:	26 bb       	out	0x16, r18	; 22
    while(!(TIFR1 & _BV(TOV1)));
    7e54:	b0 9b       	sbis	0x16, 0	; 22
    7e56:	fe cf       	rjmp	.-4      	; 0x7e54 <flashLED+0x24>
    PINB |= _BV(pin);
    7e58:	93 b1       	in	r25, 0x03	; 3
    7e5a:	93 2b       	or	r25, r19
    7e5c:	93 b9       	out	0x03, r25	; 3
  } while (--count);
    7e5e:	81 50       	subi	r24, 0x01	; 1
    7e60:	a1 f7       	brne	.-24     	; 0x7e4a <flashLED+0x1a>
}
    7e62:	08 95       	ret

00007e64 <jumpToApp>:
#define WD_2S     (_BV(WDP2) | _BV(WDP1) | _BV(WDP0) | _BV(WDE))
#define WD_4S     (_BV(WDP3) | _BV(WDE))
#define WD_8S     (_BV(WDP3) | _BV(WDP0) | _BV(WDE))

static inline void setWatchdog(uint8_t timeout) {
    WDTCSR = _BV(WDCE) | _BV(WDE);
    7e64:	e0 e6       	ldi	r30, 0x60	; 96
    7e66:	f0 e0       	ldi	r31, 0x00	; 0
    7e68:	88 e1       	ldi	r24, 0x18	; 24
    7e6a:	80 83       	st	Z, r24
    WDTCSR = timeout;
    7e6c:	10 82       	st	Z, r1
void jumpToApp() {
    // Jump to app start address (0x0000)
    // this is done by setting the Z register (R31:R30) to 0
    // and do indirect jump (IJMP)
    setWatchdog(WD_OFF);
    __asm__ __volatile__ (
    7e6e:	ee 27       	eor	r30, r30
    7e70:	ff 27       	eor	r31, r31
    7e72:	09 94       	ijmp
